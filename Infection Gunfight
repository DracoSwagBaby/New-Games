local NotificationLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/lobox920/Notification-Library/Main/Library.lua"))()
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

NotificationLibrary:SendNotification("Info", "Menu Is Loading...", 3)
wait(4)
NotificationLibrary:SendNotification("Info", "Anti-Ban Is Loading...", 3)
wait(4)
NotificationLibrary:SendNotification("Success", "Menu Has been Loaded!", 3)

local Window = Fluent:CreateWindow({
    Title = "Synth X | Infection Gunfight ðŸŽƒ",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftAlt -- Used when there's no MinimizeKeybind
})

-- Funktion, um den Kick und Ban zu blockieren
local function onPlayerRemoving(player)
    if player == Players.LocalPlayer then
        warn(player.Name .. " wurde versucht zu kicken oder zu bannen, aber der Kick/Ban wurde blockiert.")
        return Enum.PlayerRemoveReason.Unknown -- Blockiere den Kick/Ban
    end
end

Players.PlayerRemoving:Connect(onPlayerRemoving)

------------------------------------------------------------------------------------------------------------------------

-- Tabs
------------------------------------------------------------------------------------------------------------------------
local Tabs = {
    Visual = Window:AddTab({ Title = "Visual", Icon = "eye"}),
    Aimlock = Window:AddTab({ Title = "Aimlock", Icon = "crosshair"}),
    Character = Window:AddTab({ Title = "Character", Icon = "layers"}),
}
------------------------------------------------------------------------------------------------------------------------

-- Visual
------------------------------------------------------------------------------------------------------------------------
local Settings = {
    Box_Color = Color3.fromRGB(255, 0, 0),
    Tracer_Color = Color3.fromRGB(255, 0, 0),
    Tracer_Thickness = 1,
    Box_Thickness = 1,
    Tracer_Origin = "Bottom",
    Tracer_FollowMouse = false,
    Tracers = false
}
local Team_Check = {
    TeamCheck = false,
    Green = Color3.fromRGB(0, 255, 0),
    Red = Color3.fromRGB(255, 0, 0)
}
local TeamColor = true

--// SEPARATION
local player = game:GetService("Players").LocalPlayer
local camera = game:GetService("Workspace").CurrentCamera
local mouse = player:GetMouse()
local ESPEnabled = false  -- Variable to track ESP toggle state

local function NewQuad(thickness, color)
    local quad = Drawing.new("Quad")
    quad.Visible = false
    quad.PointA = Vector2.new(0,0)
    quad.PointB = Vector2.new(0,0)
    quad.PointC = Vector2.new(0,0)
    quad.PointD = Vector2.new(0,0)
    quad.Color = color
    quad.Filled = false
    quad.Thickness = thickness
    quad.Transparency = 1
    return quad
end

local function NewLine(thickness, color)
    local line = Drawing.new("Line")
    line.Visible = false
    line.From = Vector2.new(0, 0)
    line.To = Vector2.new(0, 0)
    line.Color = color 
    line.Thickness = thickness
    line.Transparency = 1
    return line
end

local function Visibility(state, lib)
    for _, item in pairs(lib) do
        item.Visible = state
    end
end

local function ESP(plr)
    local library = {
        blacktracer = NewLine(Settings.Tracer_Thickness*2, Color3.fromRGB(0, 0, 0)),
        tracer = NewLine(Settings.Tracer_Thickness, Settings.Tracer_Color),
        black = NewQuad(Settings.Box_Thickness*2, Color3.fromRGB(0, 0, 0)),
        box = NewQuad(Settings.Box_Thickness, Settings.Box_Color),
        healthbar = NewLine(3, Color3.fromRGB(0, 0, 0)),
        greenhealth = NewLine(1.5, Color3.fromRGB(0, 255, 0))
    }

    local function UpdateColors()
        library.tracer.Color = Settings.Tracer_Color
        library.box.Color = Settings.Box_Color
    end

    local function Updater()
        local connection
        connection = game:GetService("RunService").RenderStepped:Connect(function()
            if not ESPEnabled then
                Visibility(false, library)
                return
            end

            if plr.Character and plr.Character:FindFirstChild("Humanoid") and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character.Humanoid.Health > 0 then
                local HumPos, OnScreen = camera:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
                if OnScreen then
                    UpdateColors()  -- Update colors based on current Settings
                    
                    -- Update ESP box and tracer positions and visibility
                    local head = camera:WorldToViewportPoint(plr.Character.Head.Position)
                    local DistanceY = math.clamp((Vector2.new(head.X, head.Y) - Vector2.new(HumPos.X, HumPos.Y)).magnitude, 2, math.huge)
                    
                    local function Size(item)
                        item.PointA = Vector2.new(HumPos.X + DistanceY, HumPos.Y - DistanceY*2)
                        item.PointB = Vector2.new(HumPos.X - DistanceY, HumPos.Y - DistanceY*2)
                        item.PointC = Vector2.new(HumPos.X - DistanceY, HumPos.Y + DistanceY*2)
                        item.PointD = Vector2.new(HumPos.X + DistanceY, HumPos.Y + DistanceY*2)
                    end
                    Size(library.box)
                    Size(library.black)

                    if Settings.Tracers then
                        library.tracer.From = Settings.Tracer_Origin == "Middle" and camera.ViewportSize*0.5 or Vector2.new(camera.ViewportSize.X*0.5, camera.ViewportSize.Y)
                        if Settings.Tracer_FollowMouse then
                            library.tracer.From = Vector2.new(mouse.X, mouse.Y + 36)
                        end
                        library.tracer.To = Vector2.new(HumPos.X, HumPos.Y + DistanceY*2)
                    else
                        library.tracer.From = Vector2.new(0, 0)
                        library.tracer.To = Vector2.new(0, 0)
                    end

                    local d = (Vector2.new(HumPos.X - DistanceY, HumPos.Y - DistanceY*2) - Vector2.new(HumPos.X - DistanceY, HumPos.Y + DistanceY*2)).magnitude
                    local healthoffset = plr.Character.Humanoid.Health/plr.Character.Humanoid.MaxHealth * d

                    library.greenhealth.From = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2)
                    library.greenhealth.To = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2 - healthoffset)

                    library.healthbar.From = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2)
                    library.healthbar.To = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y - DistanceY*2)

                    Visibility(true, library)
                else
                    Visibility(false, library)
                end
            else
                Visibility(false, library)
                if not game.Players:FindFirstChild(plr.Name) then
                    connection:Disconnect()
                end
            end
        end)
    end

    coroutine.wrap(Updater)()
end

for _, v in pairs(game:GetService("Players"):GetPlayers()) do
    if v.Name ~= player.Name then
        coroutine.wrap(ESP)(v)
    end
end

game.Players.PlayerAdded:Connect(function(newplr)
    if newplr.Name ~= player.Name then
        coroutine.wrap(ESP)(newplr)
    end
end)

-- Adding the ESP Toggle
local Toggle = Tabs.Visual:AddToggle("ESP Toggle", 
{
    Title = "ESP Toggle", 
    Description = "Toggle the ESP visibility",
    Default = false,
    Callback = function(state)
        ESPEnabled = state
        print(state and "ESP Enabled" or "ESP Disabled")
    end 
})

-- Adding the Tracers Toggle
local TracersToggle = Tabs.Visual:AddToggle("Tracers Toggle", 
{
    Title = "Tracers Toggle", 
    Description = "Toggle the visibility of Tracers",
    Default = false,
    Callback = function(state)
        Settings.Tracers = state
        print(state and "Tracers Enabled" or "Tracers Disabled")
    end 
})


-- Adding the Color Picker for both Tracer and ESP Box Color
local ESPColorPicker = Tabs.Visual:AddColorpicker("ESP and Tracer Color", 
{
    Title = "ESP and Tracer Color",
    Description = "Choose a color for both ESP boxes and tracers",
    Default = Settings.Box_Color,
    Callback = function(color)
        Settings.Box_Color = color
        Settings.Tracer_Color = color
        print("ESP and Tracer Color updated:", color)
    end
})
------------------------------------------------------------------------------------------------------------------------

-- Aimlock
------------------------------------------------------------------------------------------------------------------------
local teamCheck = false
local fov = 95  -- Default FOV value
local smoothing = 1
local predictionFactor = 0  -- Adjust this factor to improve prediction accuracy
local highlightEnabled = false -- Variable to enable or disable target highlighting.
local lockPart = "Head"  -- Choose what part it locks onto. Ex. HumanoidRootPart or Head

local ToggleKey = Enum.KeyCode.E  -- Choose the key for toggling aimbot lock

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")

local FOVring = Drawing.new("Circle")
FOVring.Visible = false  -- Initially set FOV ring to not visible
FOVring.Thickness = 1
FOVring.Radius = fov
FOVring.Transparency = 0.8
FOVring.Color = Color3.fromRGB(255, 128, 128)
FOVring.Position = workspace.CurrentCamera.ViewportSize / 2

local currentTarget = nil
local aimbotEnabled = false  -- Initially set aimbot to disabled
local toggleState = false  -- Variable to keep track of toggle state
local debounce = false  -- Debounce variable
local fovEnabled = false  -- Variable to control FOV ring visibility (start off)

local function getClosest(cframe)
    local ray = Ray.new(cframe.Position, cframe.LookVector).Unit
    local target = nil
    local mag = math.huge
    local screenCenter = workspace.CurrentCamera.ViewportSize / 2

    for _, v in pairs(Players:GetPlayers()) do
        if v.Character and v.Character:FindFirstChild(lockPart) and v.Character:FindFirstChild("Humanoid") and v.Character:FindFirstChild("HumanoidRootPart") and v ~= Players.LocalPlayer and (v.Team ~= Players.LocalPlayer.Team or not teamCheck) then
            local screenPoint, onScreen = workspace.CurrentCamera:WorldToViewportPoint(v.Character[lockPart].Position)
            local distanceFromCenter = (Vector2.new(screenPoint.X, screenPoint.Y) - screenCenter).Magnitude

            if onScreen and distanceFromCenter <= fov then
                local magBuf = (v.Character[lockPart].Position - ray:ClosestPoint(v.Character[lockPart].Position)).Magnitude

                if magBuf < mag then
                    mag = magBuf
                    target = v
                end
            end
        end
    end

    return target
end

local function updateFOVRing()
    if fovEnabled then  -- Only update if FOV is enabled
        FOVring.Position = workspace.CurrentCamera.ViewportSize / 2
        FOVring.Visible = true  -- Show the FOV ring
    else
        FOVring.Visible = false  -- Hide the FOV ring
    end
end

local function highlightTarget(target)
    if highlightEnabled and target and target.Character then
        local highlight = Instance.new("Highlight")
        highlight.Adornee = target.Character
        highlight.FillColor = Color3.fromRGB(255, 255, 255)
        highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
        highlight.Parent = target.Character
    end
end

local function removeHighlight(target)
    if highlightEnabled and target and target.Character and target.Character:FindFirstChildOfClass("Highlight") then
        target.Character:FindFirstChildOfClass("Highlight"):Destroy()
    end
end

local function predictPosition(target)
    if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
        local velocity = target.Character.HumanoidRootPart.Velocity
        local position = target.Character[lockPart].Position
        local predictedPosition = position + (velocity * predictionFactor)
        return predictedPosition
    end
    return nil
end

-- Updated turnTowards function to only change camera orientation, not character position
local function turnTowards(target)
    if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
        local targetPosition = target.Character.HumanoidRootPart.Position
        local camera = workspace.CurrentCamera
        -- Adjust only the camera's orientation towards the target without moving the character
        camera.CFrame = CFrame.new(camera.CFrame.Position, targetPosition)
    end
end

local loop = RunService.RenderStepped:Connect(function()
    if aimbotEnabled then
        updateFOVRing()

        local localPlayer = Players.LocalPlayer.Character
        local cam = workspace.CurrentCamera

        -- Check if right mouse button is pressed and toggle is enabled
        if UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
            toggleState = true  -- Set toggle state to true while right mouse button is held down

            -- Find the closest target
            currentTarget = getClosest(cam.CFrame)
            if currentTarget then
                highlightTarget(currentTarget)  -- Highlight the new target if enabled
                turnTowards(currentTarget)  -- Turn towards the target

                if currentTarget.Character and currentTarget.Character:FindFirstChild(lockPart) then
                    local predictedPosition = predictPosition(currentTarget)
                    if predictedPosition then
                        workspace.CurrentCamera.CFrame = workspace.CurrentCamera.CFrame:Lerp(CFrame.new(cam.CFrame.Position, predictedPosition), smoothing)
                    end
                    FOVring.Color = Color3.fromRGB(0, 255, 0)  -- Change FOV ring color to green when locked onto a target
                end
            end
        else
            toggleState = false  -- Reset toggle state when right mouse button is released
            if currentTarget and highlightEnabled then
                removeHighlight(currentTarget)  -- Remove highlight from the old target
            end
            currentTarget = nil
            FOVring.Color = Color3.fromRGB(255, 128, 128)  -- Revert FOV ring color to original when not locked onto a target
        end
    end
end)

-- Toggle for the Aimbot
local AimbotToggle = Tabs.Aimlock:AddToggle("AimbotToggle", 
{
    Title = "Toggle Aimbot", 
    Description = "Toggle the aimbot on or off.",
    Default = false,
    Callback = function(state)
        aimbotEnabled = state  -- Update aimbot enabled state
        if state then
            print("Aimbot Enabled")
        else
            print("Aimbot Disabled")
            currentTarget = nil  -- Clear target when aimbot is disabled
            FOVring.Visible = false  -- Hide FOV ring when aimbot is off
        end
    end 
})

-- Toggle for the FOV ring
local FOVToggle = Tabs.Aimlock:AddToggle("FOVToggle", 
{
    Title = "Toggle FOV Ring", 
    Description = "Toggle the visibility of the FOV ring.",
    Default = false,  -- Default is false to hide the FOV ring initially
    Callback = function(state)
        fovEnabled = state  -- Update FOV enabled state
        if state then
            print("FOV Ring Enabled")
        else
            print("FOV Ring Disabled")
            FOVring.Visible = false  -- Hide FOV ring when toggled off
        end
    end 
})

-- Slider for adjusting the FOV
local FOVSlider = Tabs.Aimlock:AddSlider("FOVSlider", 
{
    Title = "Adjust FOV", 
    Description = "Adjust the field of view (FOV)",
    Default = fov,
    Min = 0,
    Max = 200,  -- Set a maximum value for the FOV
    Rounding = 1,
    Callback = function(value)
        fov = value  -- Update the local fov variable
        FOVring.Radius = fov  -- Update the FOV ring radius
        print("FOV changed to:", value)  -- Print the new FOV value
    end 
})




------------------------------------------------------------------------------------------------------------------------

-- Animation
------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------

-- Character
------------------------------------------------------------------------------------------------------------------------
-- Initialize services and variables
local localPlayer = game:GetService("Players").LocalPlayer
local uis = game:GetService("UserInputService")
local rs = game:GetService("RunService")
local isMoving = {W = false, A = false, S = false, D = false} -- Table to track movement keys
local multiplier = 1 
local movementEnabled = false -- Movement starts disabled

-- Display a hint for 2 seconds
task.spawn(function()
    local hint = Instance.new("Hint", workspace)
    task.wait(2)
    hint:Destroy()
end)

-- Function to move the character based on key input
local function moveCharacter()
    if movementEnabled and localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local direction = Vector3.new(0, 0, 0)
        local camera = workspace.CurrentCamera

        -- Adjust the direction based on pressed keys
        if isMoving.W then
            direction = direction + Vector3.new(camera.CFrame.LookVector.X, 0, camera.CFrame.LookVector.Z) -- Forward
        end
        if isMoving.A then
            direction = direction - Vector3.new(camera.CFrame.RightVector.X, 0, camera.CFrame.RightVector.Z) -- Left
        end
        if isMoving.S then
            direction = direction - Vector3.new(camera.CFrame.LookVector.X, 0, camera.CFrame.LookVector.Z) -- Backward
        end
        if isMoving.D then
            direction = direction + Vector3.new(camera.CFrame.RightVector.X, 0, camera.CFrame.RightVector.Z) -- Right
        end

        -- Normalize direction and move the character
        if direction.Magnitude > 0 then
            direction = direction.Unit * multiplier
            localPlayer.Character.HumanoidRootPart.CFrame = localPlayer.Character.HumanoidRootPart.CFrame + direction
        end
    end
end

-- Key press detection for W, A, S, D
uis.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if input.KeyCode == Enum.KeyCode.W then
        isMoving.W = true
    elseif input.KeyCode == Enum.KeyCode.A then
        isMoving.A = true
    elseif input.KeyCode == Enum.KeyCode.S then
        isMoving.S = true
    elseif input.KeyCode == Enum.KeyCode.D then
        isMoving.D = true
    end
end)

-- Stop moving when the key is released
uis.InputEnded:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    if input.KeyCode == Enum.KeyCode.W then
        isMoving.W = false
    elseif input.KeyCode == Enum.KeyCode.A then
        isMoving.A = false
    elseif input.KeyCode == Enum.KeyCode.S then
        isMoving.S = false
    elseif input.KeyCode == Enum.KeyCode.D then
        isMoving.D = false
    end
end)

-- Update the character's position every frame based on key input
rs.RenderStepped:Connect(moveCharacter)

-- GUI Integration for Toggle and Slider
local Tab = {} -- Replace this with your actual tab object for the GUI

-- Toggle to enable/disable movement
local Toggle = Tabs.Character:AddToggle("MyToggle", 
{
    Title = "Movement Toggle", 
    Description = "Enable or disable movement.",
    Default = false, -- Start with movement disabled
    Callback = function(state)
        movementEnabled = state
        if state then
            print("Movement Enabled")
        else
            print("Movement Disabled")
        end
    end 
})

-- Slider to control speed multiplier
local Slider = Tabs.Character:AddSlider("Slider", 
{
    Title = "Speed Multiplier",
    Description = "Adjust the movement speed.",
    Default = 0,
    Min = 0.5,
    Max = 1,
    Rounding = 1,
    Callback = function(value)
        multiplier = value
        print("Speed Multiplier set to:", value)
    end
})

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")

local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Noclipping = nil
local Clip = false

-- Create a function to toggle noclip
local function toggleNoclip(state)
    Clip = not state -- Invert state to match toggle
    if state then
        print("Noclip On")
        -- Start the noclip loop
        Noclipping = RunService.Stepped:Connect(function()
            if Clip == false and LocalPlayer.Character ~= nil then
                for _, child in pairs(LocalPlayer.Character:GetDescendants()) do
                    if child:IsA("BasePart") and child.CanCollide == true then
                        child.CanCollide = false
                    end
                end
            end
        end)
    else
        print("Noclip Off")
        -- Stop the noclip loop
        if Noclipping then
            Noclipping:Disconnect()
            Noclipping = nil
        end
        -- Reset collision on all parts
        if LocalPlayer.Character then
            for _, child in pairs(LocalPlayer.Character:GetDescendants()) do
                if child:IsA("BasePart") then
                    child.CanCollide = true
                end
            end
        end
    end
end

-- Add the toggle for noclip
local Toggle = Tabs.Character:AddToggle("NoclipToggle", 
{
    Title = "Noclip", 
    Description = "Toggle noclip on/off",
    Default = false,
    Callback = function(state)
        toggleNoclip(state)
    end 
})

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")

local infJump
local infJumpDebounce = false
local ascending = false

-- Function to enable or disable infinite jump
local function toggleInfJump(state)
    if state then
        if infJump then infJump:Disconnect() end
        infJumpDebounce = false
        infJump = UserInputService.JumpRequest:Connect(function()
            if not infJumpDebounce then
                infJumpDebounce = true
                LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid"):ChangeState(Enum.HumanoidStateType.Jumping)
                wait()
                infJumpDebounce = false
            end
        end)
        print("Infinite Jump On")
    else
        if infJump then infJump:Disconnect() end
        infJumpDebounce = false
        print("Infinite Jump Off")
    end
end

-- Function to handle the ascent when Backspace is held
local function onInputBegan(input, gameProcessedEvent)
    if not gameProcessedEvent and input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == Enum.KeyCode.Backspace then
            ascending = true
            while ascending do
                if LocalPlayer.Character then
                    LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid"):ChangeState(Enum.HumanoidStateType.Jumping)
                end
                wait(0.1) -- Adjust this value for speed of ascent
            end
        end
    end
end

local function onInputEnded(input, gameProcessedEvent)
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.Backspace then
        ascending = false
    end
end

-- Connect input events
UserInputService.InputBegan:Connect(onInputBegan)
UserInputService.InputEnded:Connect(onInputEnded)

-- Add the toggle for infinite jump
local Toggle = Tabs.Character:AddToggle("InfJumpToggle", 
{
    Title = "Infinite Jump", 
    Description = "Toggle infinite jump on/off",
    Default = false,
    Callback = function(state)
        toggleInfJump(state) -- Call the function to enable/disable infinite jump
    end 
})


------------------------------------------------------------------------------------------------------------------------

-- Troll    
------------------------------------------------------------------------------------------------------------------------
